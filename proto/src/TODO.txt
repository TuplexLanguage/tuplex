
Symbol table rewrite - DONE

Central compiler "driver" routine and options handling - DONE

Modules and import handling - DONE

Generic (parameterized) types except for reentrant code generation - DONE

Proper integer literal type handling, range checking and conversion - DONE

Bool type and boolean expressions - DONE

Polymorphism (virtual lookup) for static members - DONE

Function objects retaining their closure (e.g. 'self') - DONE

Preserve type information in references - DONE

'self' implicit method argument - DONE

Virtual methods - DONE

'new' operator and heap allocation - DONE

Initializers / constructors - DONE
super() constructor invocation; super.method() invocation - DONE

Refactor symbols, declarations, definitions/entities/fields/types - DONE
 - Break apart SymbolScope and Entity objects; join TypeEntity and Type hierarchy
 - SymbolScope created in declaration phase
 - Entities (now represent definitions) created in resolution phase
 - TxType fully defined upon construction (during type resolution pass)

Generic type instance fields support (with Ref contraint type) - DONE
 - The AST for a type definition is re-entrant, and reprocessed for each specialization

Interfaces - DONE

Syntax support for writing negative tests (expecting compiler errors) - DONE

Author test harness / automatic testing suite - DONE

Change statement syntax from \n to ; - DONE

Change function header syntax from 'func' to ()-> - DONE

Implement syntactic sugar for automatic reference dereferencing (implicit '^') - DONE

Refactor TxType instantiation - multi-pass so that "cyclic" references possible - DONE

Fix instantiation of ref-constrained type parameters (they should get unique names like other specializations) - DONE

Fix / revise TYPE parameter declaration ("hashed" binding members) - DONE

Refactor expression conversion wrapping so that each specialization-index has an independent conversion evaluation - DONE

Generic type instance fields support (with Any contraint type) - DONE
 - To support declaring instance fields of dynamically resolved type by value (not just reference)

Proper recursive expression checking (fields; types) - DONE

Remove validation pass (move checks to resolution pass) - DONE

Support recursive type definition by reference (CRTP) (e.g. type Bar Foo< Ref<Bar> >) - DONE!!!!!

Make fields be "bindings to entities" rather than "entities" - DONE
 - in order to fix multi-instantiation in e.g:
  stackObj := AType();  ## shall not allocates twice & copy

Implement "development mode" in compiler, if disabled then:
 - bc file generated by default - DONE
 - no jit by default - DONE
 - no compiler assertions - DONE
 - no trace logging invocations - DONE

Review conversion node handling - DONE
 - should be allocated in node constructors (not decl/resolve passes)

Overhaul concrete fields checking - DONE
 - distinguish between parameters that are ref-constrained and that aren't
 - handle lexically nested generic and non-generic types appropriately

Proper mutability handling: - DONE
 - in compound expressions, e.g. mut.immut.mut.immut ...
 - mutating and non-mutating methods

Array literals - DONE

Make VALUE type parameters proper instance fields - DONE
 - implement correct Array type handling

Implement proper modifiability determination across expression chains - DONE

Be able to specialize an immutable version of mutable generic types, so that they can accept immutable type bindings - DONE
 - review inheritance and mutability (including interface adapters)

Generate statically constant operations for statically constant value expressions - DONE
 - should also enable arbitrary declaration order of global constants 

Support augmenting built-in types' definitions in tuplex code - DONE

Bounds checking on array element access (add implicit AST for this in TxElemDerefNode) - DONE

Bounds checking on array element assignment - DONE

Sequence interfaces first version - DONE

Range type - DONE

Advanced for-loops - DONE

String datatype - DONE

Panic statement - DONE

Foreign function interface - DONE

Make VALUE type parameter specializations share a general (but non-generic) supertype - DONE

Conditional reference type casting: - DONE
    if other is oa : &Array { ... }

Array object assignment, review and test semantics
 - correct setting of L
 - truncation (all elements don't fit in target) ok?

Default initialization of array elements (at least if it's array of arrays)

Dynamic-length arrays tests - bounds checking, copying, etc - PARTIALLY DONE

Ensure VALUE type parameters are always correctly initialized



Ensure Ref<P> is-a Ref<Q> if P is-a Q



For VALUEs below a threshold (e.g. <= 4), coge-gen individual specializations for efficiency



Array initialization from sequence
    arr := []Int( seq );  ## of type Sequencable<Int>
    arr := [ seq... ];
    arr := [ 0..2... ];

Auto-conversion of array initialization elements (literals; also from sequences?)

Support negative array indexing from array end



Ensure fields are always initialized (with the default constructor if no init expr provided)
 - Remove 'initialization' code from alloca (at least for arrays this will cause double init of C and L)

Implement advanced implicit constructor concept
 - Automatically generate the basic constructor (one argument for each instance member (except const with initializer))
   - basic constructor has 'self' as pseuodo-return value, so user constructors can operate object only after it is properly initialized
 - Allow instance members' inlined initializers?
 - Default (zero arguments) constructor if base type and all members without inlined initializers allow default construction?

Constructor initialization validation check: That each constructor properly initializes all members (without inlined initializers)



Virtual dereferencing of abstract references for array subscripting, implicitly creating a reference to the element?
    r : &Array;  s : &Array;
    r[0] == s[0]

Remove assumption that bound parameters are "concrete": Shall be ok to bind interfaces and abstract superclasses.
 - See elementary types that implement Enumerable<E>

Evaluate whether TYPE type parameter constraint types shall be resolved in each type specialization instead of in gen base type,
 in order to allow them to depend on the binding:
  - Would (probably) support more specific ERange specification:
    public type ERange< E derives Enumerable<E> > implements Range< E >
                                            ^^^

Dataspace syntax support, continued

max & min intrinsics

modulo & remainder intrinsics

Basic Floatingpoint intrinsics:
 - floor & ceiling
 - fraction
 - sign
 - epsilon

Assignment-operators:
 - arithmetic ( += etc )
 - bitwise and logical

break and continue out of nested loops

Syntactic sugar for ref and array types in type arguments (possibly chained), e.g. Subtype<&Int> instead of Subtype<Ref<Int>>

Implement implicit static initializer function for types' static members and static code

Implement debugging info

Type reflection, at least for autotesting, some ideas:
    assert static_type(var) == static_type(Ref<Parent>)
    assert type(var^) == type(Child)
    #exptype( var, Ref<Parent> )  ## compilation test, no code generated
    #exptype( var, "$local.Foo.$type" )  ## compilation test, no code generated

Support overloading of virtual methods

Autotests for conversions and default constructions for elementary types
  - both expression construction, stack field construction, and static construction

Tuple literals

Destructors

Union typeclass

Full dataspaces support

Shared objects

Overhaul function overloading (permitting "near-matches") together with implicit type conversion code

Implement symbol visibility (private etc)

Enum typeclass

Support non-constant static initializers (i.e. executed before main())

Ideal concrete fields checking
 - ideally bottom-up: any construct that is dependent on generic parameter causes container to be dependent (and non-concrete)
 - methods may have function signature independent of generics, but contain code that is dependent on generic parameters
