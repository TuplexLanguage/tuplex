
Symbol table rewrite - DONE

Central compiler "driver" routine and options handling - DONE

Modules and import handling - DONE

Generic (parameterized) types except for reentrant code generation - DONE

Proper integer literal type handling, range checking and conversion - DONE

Bool type and boolean expressions - DONE

Polymorphism (virtual lookup) for static members - DONE

Function objects retaining their closure (e.g. 'self') - DONE

Preserve type information in references - DONE

'self' implicit method argument - DONE

Virtual methods - DONE

'new' operator and heap allocation - DONE

Initializers / constructors - DONE
super() constructor invocation; super.method() invocation - DONE

Refactor symbols, declarations, definitions/entities/fields/types - DONE
 - Break apart SymbolScope and Entity objects; join TypeEntity and Type hierarchy
 - SymbolScope created in declaration phase
 - Entities (now represent definitions) created in resolution phase
 - TxType fully defined upon construction (during type resolution pass)

Generic type instance fields support (with Ref contraint type) - DONE
 - The AST for a type definition is re-entrant, and reprocessed for each specialization

Interfaces - DONE

Syntax support for writing negative tests (expecting compiler errors) - DONE

Author test harness / automatic testing suite - DONE

Change statement syntax from \n to ; - DONE

Change function header syntax from 'func' to ()-> - DONE

Implement syntactic sugar for automatic reference dereferencing (implicit '^') - DONE

Refactor TxType instantiation - multi-pass so that "cyclic" references possible - DONE

Fix instantiation of ref-constrained type parameters (they should get unique names like other specializations) - DONE

Fix / revise TYPE parameter declaration ("hashed" binding members) - DONE

Refactor expression conversion wrapping so that each specialization-index has an independent conversion evaluation - DONE

Generic type instance fields support (with Any contraint type) - DONE
 - To support declaring instance fields of dynamically resolved type by value (not just reference)

Proper recursive expression checking (fields; types) - DONE

Remove validation pass (move checks to resolution pass) - DONE

Support recursive type definition by reference (CRTP) (e.g. type Bar Foo< Ref<Bar> >) - DONE!!!!!

Make fields be "bindings to entities" rather than "entities" - DONE
 - in order to fix multi-instantiation in e.g:
  stackObj := AType();  ## shall not allocates twice & copy

Implement "development mode" in compiler, if disabled then:
 - bc file generated by default - DONE
 - no jit by default - DONE
 - no compiler assertions - DONE
 - no trace logging invocations - DONE

Review conversion node handling - DONE
 - should be allocated in node constructors (not decl/resolve passes)

Overhaul concrete fields checking - DONE
 - distinguish between parameters that are ref-constrained and that aren't
 - handle lexically nested generic and non-generic types appropriately

Proper mutability handling: - DONE
 - in compound expressions, e.g. mut.immut.mut.immut ...
 - mutating and non-mutating methods

Array literals - DONE

Make VALUE type parameters proper instance fields - DONE
 - implement correct Array type handling

Implement proper modifiability determination across expression chains - DONE

Be able to specialize an immutable version of mutable generic types, so that they can accept immutable type bindings - DONE
 - review inheritance and mutability (including interface adapters)

Generate statically constant operations for statically constant value expressions - DONE
 - should also enable arbitrary declaration order of global constants 

Support augmenting built-in types' definitions in tuplex code - DONE

Bounds checking on array element access (add implicit AST for this in TxElemDerefNode) - DONE

Bounds checking on array element assignment - DONE

Sequence interfaces first version - DONE

Range type - DONE

Advanced for-loops - DONE

String datatype - DONE

Panic statement - DONE

Foreign function interface - DONE

Syntactic sugar for ref and array types in type arguments (possibly chained), e.g. Subtype<&Int> instead of Subtype<Ref<Int>> - DONE

Make VALUE type parameter specializations share a general (but non-generic) supertype - DONE

Basic type reflection ( _typeid(), isa() ) - DONE

Conditional reference type casting: - DONE
    if other is oa : &Array { ... }

Array object assignment, review and test semantics - DONE

Dynamic-length arrays tests - bounds checking, copying, etc - DONE

Support main( args ) program arguments - DONE

Implement basic debugging info - DONE


Secure Initialization
---------------------
Ensure fields are always initialized - DONE

Implement advanced constructor initialization concept - DONE
 - 'self' as pseuodo-return value, so user constructors can operate object only after it is properly initialized
 - Allow instance members' inlined initializers

Constructor initialization validation check: That each constructor properly initializes all members (without inlined initializers) - DONE

Support named member initialization, preventing excessive copying-by-value for large members - DONE


Remaining core array features:
------------------------------
Review array mutability vs element mutability handling - DONE
 - avoid inconsistency between them such as: ~Array<UByte>

Let nested array assignment statements support implicit initialization of assignee's outer array elements - DONE
    aaa : ~[4][4][4]UByte;  aaa[0][0][0] = 17;

Array 'fill' constructor

Array initialization from sequence; sequence expansion
 - requires custom modifiability handling
    arr := []Int( seq );  ## of type Sequencable<Int>
    arr := [ seq... ];
    arr := [ 0..2... ];

Basic working Matrix type


Releasing Resources
-------------------
Freeing memory (delete statement) - DONE

Destructors



Misc
----
Windows / Visual Studio development & build support

Improved FFI support
 - opaque 64b pointer type
 - structs <-> Tuples

Change keyword from 'virtual' to 'static'

Number parsing functions atou() atoi() atof()


========= MILESTONE ==========



Dataspace support
 - overhaul syntax and grammar handling
 - full semantics and verification



Advanced array and range features
---------------------------------
Sub-range production:  arr[2..5]

Support negative array indexing from array end

Support method overloading for closure-modifying (and not) methods
 - allow for loops to select sequencer()~ for mutable seq's

Auto-conversion of array initialization elements (literals; also from sequences?)

Virtual dereferencing of abstract references for array subscripting, implicitly creating a reference to the element?
    r : &Array;  s : &Array;
    r[0] == s[0]

For VALUEs below a threshold (e.g. <= 4), coge-gen individual specializations for efficiency



Advanced type handling
----------------------
Support runtime is-a tests for interface adapters

Support boolean test expression for: Ref<P> is-a Ref<Q> if P is-a Q

Extend resolve_type()/define_type() to resolve_type_and_attributes()/define_type_and_attributes()
 - for bottom-up analysis of attributes:
   - generic-parameter-dependent (both TYPE and VALUE)
   - statically constant expressions
 - applies to RESOLUTION_PASS

Remove assumption that bound parameters are "concrete": Shall be ok to bind interfaces and abstract superclasses.
 - See elementary types that implement Enumerable<E>

Evaluate whether TYPE type parameter constraint types shall be resolved in each type specialization instead of in gen base type,
 in order to allow them to depend on the binding:
  - Would (probably) support more specific ERange specification:
    public type ERange< E derives Enumerable<E> > implements Range< E >
                                            ^^^


Arithmetic features
-------------------
Separate bitwise and logical operators, so that bitwise can have higher priority than comparison operators:
  Bitwise: && || &| !
  Logical: & | != !

max & min intrinsics

modulo & remainder intrinsics

Basic Floatingpoint intrinsics:
 - floor & ceiling
 - fraction
 - sign
 - epsilon

Assignment-operators:
 - arithmetic ( += etc )
 - bitwise and logical



Improved overloading
--------------------
Support overloading of virtual methods

Overhaul function overloading (permitting "near-matches") together with implicit type conversion code



Implicit Tuples support
-----------------------
Tuple literals

Multi-valued function returns (i.e. return tuple)



Miscellaneous
-------------

Implement advanced debugging info
 - self, super fields in methods
 - non-local fields
 - expressions, rvalues, etc
 - generic type parameters?

break and continue out of nested loops

Implement implicit static initializer function for types' static members and static code

Shared objects

Union typeclass

Enum typeclass

Switch-like statements

Support non-constant static initializers (i.e. executed before main())

Ideal concrete fields checking
 - ideally bottom-up: any construct that is dependent on generic parameter causes container to be dependent (and non-concrete)
 - methods may have function signature independent of generics, but contain code that is dependent on generic parameters

Auto-generate default (zero arguments) constructor if base type and all members without inlined initializers allow default construction?

Implement symbol visibility (private etc)?
