## Tests the various ways arrays can be declared and initialized with and without modifiability.

/*
Array modifiability syntactic sugar:

 - should not apply to conventional array type expression (Array{Type})

 - ~Array{Int} is inconsistent
 
 - Array{~Int} is technically consistent (and may occur for array members in generic types)

 - [ ... ] literals always immutable

 - []Type is immutable

 - Shall these be made equivalent?
   ~[]Type
   []~Type
   ~[]~Type
*/

write( a : Ref{ ~Array{~UByte,3} } ) : {
    a[0] = 'P';
    a[1] = 'I';
    a[2] = 0;
}

write( a : Ref{ ~Array{~Int,3} } ) : {
    a[0] = 1;
    a[1] = 1;
    a[2] = 0;
}

array_modifiability() : {
    ## Without sugar, all components must be specified as mod: element type, array type, and the field.

    ## specific array types - no implicit modifiability applied:
    {
        a0 : Array{UByte,3} = [0]UByte();
        #experr 1: write( &a0 );
    
        a1 : Array{~UByte,3} = [0]UByte();
        #experr 1: write( &a1 );
    
        #experr 1: a2 : ~Array{UByte,3} = [0]UByte();  ## inconsistent array type

        a3 : ~Array{~UByte,3} = [0]UByte();
        write( &a3 );
    }

    ## array type syntax sugar - implicit modifiability applied:
    {
        a10 : [3]UByte = [0]UByte();
        #experr 1: write( &a10 );
    
        a11 : ~[3]UByte = [0]UByte();
        write( &a11 );
    
        a12 : [3]~UByte = [0]UByte();
        write( &a12 );
    
        a13 : ~[3]~UByte = [0]UByte();
        write( &a13 );
    }

    ## modifiable field def syntax sugar - implicit modifiability applied:
    {
        init := c"HI";

        a20 := init;
        #experr 1: write( &a20 );

        a21 := ~ init;
        write( &a21 );
    }

    ## specific array stack constructor - no implicit modifiability applied, but assignee specifies its modifiability:
    {
        a30 := Array{Int,3}();
        #experr 1: write( &a30 );

        a31 := Array{~Int,3}();
        #experr 1: write( &a31 );

        #experr 0: a32 := ~Array{Int,3}();  ## inconsistent array type  TODO: revise error recognition

        a33 := ~Array{~Int,3}();
        write( &a33 );
    }

    ## array stack constructor syntax sugar - implicit modifiability applied:
    {
        a40 := [3]UByte();
        #experr 1: write( &a40 );

        a41 := [3]~UByte();
        write( &a41 );

        a42 := ~[3]UByte();
        write( &a42 );

        a43 := ~[3]~UByte();
        write( &a43 );
    }

    ## array literals syntax sugar - implicit modifiability applied:
    {
        a50 := [ 1, 2, 3 ];
        #experr 1: write( &a50 );

        a51 := [ UByte(1), 2, 3 ];
        #experr 1: write( &a51 );

        a52 := ~ [ 1, 2, 3 ];
        write( &a52 );

        a53 := ~[ UByte(1), 2, 3 ];
        write( &a53 );
        
        a54 := [ ~UByte(1), 2, 3 ];
        #experr 1: write( &a54 );
    }

    ## array type aliasing
    {
        type ImmArr1 <: Array{UByte,3};
        #experr 1: ~a60 := ImmArr1( [ 1, 2, 3 ] );

        type ImmArr3 <: Array{~UByte,3};
        #experr 1: ~a62 := ImmArr3( [ 1, 2, 3 ] );

        #experr 1: type ImmArr2 <: ~Array{UByte,3};    ## base type expression can't begin with modifiable token
        #experr 1: type ImmArr4 <: ~Array{~UByte,3};   ## base type expression can't begin with modifiable token

        #experr 1: type ~ MutArr1 <: Array{Short,3};   ## inconsistent array type
        #experr 1: type ~ MutArr2 <: ~Array{UByte,3};  ## base type expression can't begin with modifiable token
        #experr 1: type ~ MutArr3 <: ~Array{~UByte,3}; ## base type expression can't begin with modifiable token

        type ~ MutArr4 <: Array{~UByte,3};
        a66 := ~ MutArr4( [ 1, 2, 3 ] );
        write( &a66 );

        type ~ MutArr5 <: [3]UByte;
        a68 := ~ MutArr5( [ 1, 2, 3 ] );
        write( &a68 );

        type ~ MutArr7 <: [3]~UByte;
        a70 := ~ MutArr7( [ 1, 2, 3 ] );
        write( &a70 );

        #experr 1: type ~ MutArr6 <: ~[3]UByte;   ## base type expression can't begin with modifiable token
        #experr 1: type ~ MutArr8 <: ~[3]~UByte;  ## base type expression can't begin with modifiable token
    }

    ## TODO: new expressions
}

main()->Int : {
    array_modifiability();
    return 0;
}
