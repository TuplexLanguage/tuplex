## Test global fields

CONSTANT : tx.Int = 17;

CONSTANT_EXPR : tx.Int = -3+4;

CONSTANT_EXPR2 : tx.Int = CONSTANT + 5;

## TODO: support proper constant code generation for statically constant value expressions
##CONSTANT_EXPR3 : tx.Int = CONSTANT_EXPR2 + 5;

COPY := CONSTANT;

#experr 1: NONINITED : Int;


## globals may not be modifiable:
#experr 1: ~NONCONSTA := 8;
#experr 1: ~NONCONSTB : Int = 8;  ## (syntax error)
#experr 1: NONCONSTC : ~Int = 8;
#experr 1: NONCONSTD : mod Int = 8;


public PUBLIC_FIELD := 5;
protected PROTECTED_FIELD := 5;

#experr 1: static   TOO_STATIC   : Int = 5;
#experr 1: override TOO_OVERRIDE : Int = 5;
#experr 1: final    TOO_FINAL    : Int = 5;
#experr 1: abstract TOO_ABSTRACT;
#experr 2: abstract TOO_ABSTRACT_INIT := 5;


## evaluation dependency in reverse lexical order:
FIELDA := FIELDB;
FIELDB := CONSTANT;

## TODO: support for constant initializer *expressions* with reverse lexical order dependency
##FIELDC := FIELDD;
FIELDD := CONSTANT + 2;

## currently function calls (including pure ones) are regarded as non-statically-constant:
#experr: FIELDSQ := square( 3 );

square( a : Int )->Int {
    return a * a;
}


## check controlled error message upon recursive definition
## note - only one of the recursing definitions typically produce an error message

## type resolution recursion:
#experr 1: REC1 := REC2;
#experr 0: REC2 := REC1;

## initializer recursion:
#experr 1: REC3 : Int = REC4;
#experr 0: REC4 : Int = REC3;

#experr 1: REC5 := REC6;
#experr 0: REC6 : Int = REC5;

#experr 1: REC7 : Int = REC8;
#experr 0: REC8 := REC7;


## corresponding test for static type members:
type Compound {
    static OK : Int = 4;

    #experr 1: static RECA := RECB;
    #experr 0: static RECB := RECA;

    #experr 1: static RECC : Int = RECD;
    #experr 0: static RECD : Int = RECC;

    #experr 1: static RECE := RECF;
    #experr 0: static RECF : Int = RECE;

    #experr 1: static RECG : Int = RECH;
    #experr 0: static RECH := RECG;
}


main() {
    assert CONSTANT + CONSTANT_EXPR == 18;
    assert CONSTANT_EXPR2 == 22;
    ##assert CONSTANT_EXPR3 == 27;
    assert COPY == 17;
    assert FIELDA == 17;
    assert FIELDB == 17;
    ##assert FIELDC == 19;
    assert FIELDD == 19;
    assert Compound.OK == 4;
}
