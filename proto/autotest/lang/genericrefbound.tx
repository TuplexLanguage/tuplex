## tests specializations of ref-bound generic type
## TODO: Expand

module my

type ~ AType<S derives Ref> derives Tuple {
    memref : S;
    #experr 1: type GenAlias : S;  ## not currently allowed
    type GenRef <: Ref<S>;

    getref()->S {
        return self^.memref;
    }
}

type RInt <: Ref<Int>;

type ATypeRInt <: AType<RInt>;

#experr: type BadAType <: AType<Float> { ## doesn't match parameter's constraint type
}

main()->Int {
    #experr: type Err <: AType<Byte>;    ## doesn't match parameter's constraint type
    #experr: err := <AType<Short>>(2);   ## doesn't match parameter's constraint type
    #experr: type Err <: AType<AType>;   ## doesn't match parameter's constraint type

    val : Int = 42;
    aobj := ATypeRInt(val);
    sobj := ATypeRInt(val);
    hobj := new ATypeRInt(val);
    s1 : sobj.S = &val;
    s2 : sobj.my#AType#S = &val;
    ##s3 : hobj^.S;  ## type expr doesn't handle ^

    assert sobj.getref()^ == 42;
    assert hobj.getref()^ == 42;
    return 0;
}
