module tx


interface Range{ E } <: Indicable{ ULong, E } :

    abstract override sequencer() -> Ref{ ~Iterator{E} }

    abstract override count() -> ULong

    abstract override has( key : ULong ) -> Bool

    abstract override get( key : ULong ) -> E



/** A range between two values of an Enumerable type.
 */
type ERange{ E derives Enumerable } <: Tuple, Range{ E }, Stringer :

    /** The ERange iterator. */
    type ~ ERangeIterator <: Tuple, Iterator{ E } :
        _range   : &ERange{E}
        _nextIndex : ~ULong = 0

        override has_next() -> Bool :
            return self._nextIndex < self._range._indexLimit

        override has_prev() -> Bool :
            return self._nextIndex > 0

        override next() ~ -> E :
            if self._nextIndex >= self._range.count():
                panic( "No next() element in ERangeIterator" )
            ix := self._nextIndex
            self._nextIndex = self._nextIndex + 1
            return self._range._get_abs_ix( ix )

        override prev() ~ -> E :
            if self._nextIndex <= 0:
                panic( "No prev() element in ERangeIterator" )
            self._nextIndex = self._nextIndex - 1
            return self._range._get_abs_ix( self._nextIndex )


    ## valid indices are all integers between [ 0, _indexLimit )
    _indexLimit : ULong

    start : E
    limit : E
    stride : Long

    /** Constructs a conventional, ascending range [ start, limit ) with stride 1. */
    self( start : E, limit : E ) :
        minIndex : ~ULong = start.ordinal()
        if limit.ordinal() < minIndex:
            minIndex = limit.ordinal()
        indexLimit : ~ULong = limit.ordinal() - minIndex
        #init: _indexLimit( indexLimit ), start( start ), limit( limit ), stride( 1 )

    /** Constructs a range [ start, limit ) with the specified stride if inclusive is FALSE,
    *   or a range [ start, limit ] with the specified stride if inclusive is TRUE. */
    self( start : E, limit : E, stride : Long, inclusive : Bool ) :
        if stride == 0:
            panic ( "Zero stride in ERange" )
        minIndex : ~ULong = start.ordinal()
        if limit.ordinal() < minIndex:
            minIndex = limit.ordinal()
        indexLimit : ~ULong = 0
        if inclusive:
            indexLimit = 1
        if stride > 0:
            indexLimit = indexLimit + ( limit.ordinal() - minIndex + ULong(stride) - 1 ) / ULong(stride)
        else:  ## stride < 0
            indexLimit = indexLimit + ( start.ordinal() - minIndex + ULong(-stride) - 1 ) / ULong(-stride)
        #init: _indexLimit( indexLimit ), start( start ), limit( limit ), stride( stride )

    /** Constructs a range [ start, limit ) with the specified stride. */
    self( start : E, limit : E, stride : Long ) :
        #self( start, limit, stride, FALSE )

    override sequencer() -> Ref{ ~ERangeIterator } :
        return new ~ERangeIterator( self )

    rev_sequencer() -> Ref{ ~ERangeIterator } :
        iter := new ~ERangeIterator( self )
        iter._nextIndex = self._indexLimit
        return iter

    override count() -> ULong :
        return self._indexLimit

    override has( index : ULong ) -> Bool :
        return ULong(index) < self._indexLimit

    override get( index : ULong ) -> E :
        if ULong( index ) >= self._indexLimit:
            panic "Invalid range index: " %d index %% " >= " %d self._indexLimit
        return self._get_abs_ix( ULong( index ) )

    ## TODO: When overloading of virtual methods supported, let these override has() and get()
    has_( index : Long ) -> Bool :
        if index < 0:
            return ULong(-index) <= self._indexLimit
        else
            return ULong(index) < self._indexLimit

    get_( index : Long ) -> E :
        if index < 0 :
            if ULong( -index ) > self._indexLimit :
                panic "Invalid range index: " %d index %% " < -" %d self._indexLimit
            return self._get_abs_ix( self._indexLimit - ULong( -index ) )
        else
            if ULong( index ) >= self._indexLimit:
                panic "Invalid range index: " %d index %% " >= " %d self._indexLimit
            return self._get_abs_ix( ULong( index ) )

    _get_abs_ix( absIx : ULong ) -> E :
        if self.stride >= 0:
            return E.value( self.start.ordinal() + absIx * ULong( self.stride ) )
        else:
            return E.value( self.start.ordinal() - absIx * ULong( -self.stride ) )

    /** Returns TRUE if this is an ascending range (from lower ordinal to higher). */
    is_ascending() -> Bool :
        return self.stride > 0

    override string( writer : &~tx.ByteWriter ) :
        ## TODO: Either support duck-typing in generic types or provide "unchecked { ... }" mechanism (or similar)
        ## str := %s self.start %% ".." %s self.stride %% ".." %s self.limit
        str := "{ERange}"
        str.string( writer )
