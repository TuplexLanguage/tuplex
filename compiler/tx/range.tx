module tx


interface Range{ E } <: Indicable{ Long, E } :

    abstract override sequencer() -> Ref{ ~Iterator{E} }

    abstract override count() -> Ordinal

    abstract override has( key : Long ) -> Bool

    abstract override get( key : Long ) -> E



/** A range between two values of an Enumerable type.
 */
type ERange{ E derives Enumerable } <: Tuple, Range{ E }, Stringer :

    /** The ERange iterator. */
    type ~ ERangeIterator <: Tuple, Iterator{ E } :
        _range   : &ERange{E}
        _nextIndex : ~ULong = 0

        override has_next() -> Bool :
            return self._nextIndex < self._range._indexLimit

        override has_prev() -> Bool :
            return self._nextIndex > 0

        override next() ~ -> E :
            if self._nextIndex >= self._range.count():
                panic( "No next() element in ERangeIterator" )
            ix := self._nextIndex
            self._nextIndex = self._nextIndex + 1
            return self._range._get_abs_ix( ix )

        override prev() ~ -> E :
            if self._nextIndex <= 0:
                panic( "No prev() element in ERangeIterator" )
            self._nextIndex = self._nextIndex - 1
            return self._range._get_abs_ix( self._nextIndex )


    ## valid indices are all integers between [ 0, _indexLimit )
    _indexLimit : ULong

    start : E
    limit : E
    stride : Long

    self( start : E, limit : E, stride : Long ) :
        if stride == 0:
            panic ( "Zero stride in ERange" )
        indexLimit : ~ULong = 0
        if limit.ordinal() < start.ordinal():
            if stride > 0:
                panic ( "Positive stride in ERange though range is descending" )
            indexLimit = ( start.ordinal() - limit.ordinal() + ULong(-stride) - 1 ) / ULong(-stride)
        else if limit.ordinal() > start.ordinal():
            if stride < 0:
                panic ( "Negative stride in ERange though range is ascending" )
            indexLimit = ( limit.ordinal() - start.ordinal() + ULong(stride) - 1 ) / ULong(stride)
        #init: _indexLimit( indexLimit ), start( start ), limit( limit ), stride( stride )

    override sequencer() -> Ref{ ~ERangeIterator } :
        return new ~ERangeIterator( self )

    rev_sequencer() -> Ref{ ~ERangeIterator } :
        iter := new ~ERangeIterator( self )
        iter._nextIndex = self._indexLimit
        return iter

    override count() -> Ordinal :
        return Ordinal( self._indexLimit )

    override has( index : Long ) -> Bool :
        if index < 0:
            return ULong(-index) <= self._indexLimit
        else
            return ULong(index) < self._indexLimit

    override get( index : Long ) -> E :
        if index < 0 :
            if ULong( -index ) > self._indexLimit :
                panic "Invalid range index: " %d index %% " < -" %d self._indexLimit
            return self._get_abs_ix( self._indexLimit - ULong( -index ) )
        else
            if ULong( index ) >= self._indexLimit:
                panic "Invalid range index: " %d index %% " >= " %d self._indexLimit
            return self._get_abs_ix( ULong( index ) )

    _get_abs_ix( absIx : ULong ) -> E :
        if self.stride >= 0:
            return E.value( self.start.ordinal() + absIx * ULong( self.stride ) )
        else:
            return E.value( self.start.ordinal() - absIx * ULong( -self.stride ) )

    override string( writer : &~tx.ByteWriter ) :
        ## TODO: Either support duck-typing in generic types or provide "unchecked { ... }" mechanism (or similar)
        ## str := %s self.start %% ".." %s self.stride %% ".." %s self.limit
        str := "{ERange}"
        str.string( writer )
