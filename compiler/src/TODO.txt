
Symbol table rewrite - DONE

Central compiler "driver" routine and options handling - DONE

Modules and import handling - DONE

Generic (parameterized) types except for reentrant code generation - DONE

Proper integer literal type handling, range checking and conversion - DONE

Bool type and boolean expressions - DONE

Polymorphism (virtual lookup) for static members - DONE

Function objects retaining their closure (e.g. 'self') - DONE

Preserve type information in references - DONE

'self' implicit method argument - DONE

Virtual methods - DONE

'new' operator and heap allocation - DONE

Initializers / constructors - DONE
super() constructor invocation; super.method() invocation - DONE

Refactor symbols, declarations, definitions/entities/fields/types - DONE
 - Break apart SymbolScope and Entity objects; join TypeEntity and Type hierarchy
 - SymbolScope created in declaration phase
 - Entities (now represent definitions) created in resolution phase
 - TxType fully defined upon construction (during type resolution pass)

Generic type instance fields support (with Ref contraint type) - DONE
 - The AST for a type definition is re-entrant, and reprocessed for each specialization

Interfaces - DONE

Syntax support for writing negative tests (expecting compiler errors) - DONE

Author test harness / automatic testing suite - DONE

Change statement syntax from \n to ; - DONE

Change function header syntax from 'func' to ()-> - DONE

Implement syntactic sugar for automatic reference dereferencing (implicit '^') - DONE

Refactor TxType instantiation - multi-pass so that "cyclic" references possible - DONE

Fix instantiation of ref-constrained type parameters (they should get unique names like other specializations) - DONE

Fix / revise TYPE parameter declaration ("hashed" binding members) - DONE

Refactor expression conversion wrapping so that each specialization-index has an independent conversion evaluation - DONE

Generic type instance fields support (with Any contraint type) - DONE
 - To support declaring instance fields of dynamically resolved type by value (not just reference)

Proper recursive expression checking (fields; types) - DONE

Remove validation pass (move checks to resolution pass) - DONE

Support recursive type definition by reference (CRTP) (e.g. type Bar Foo< Ref<Bar> >) - DONE!!!!!

Make fields be "bindings to entities" rather than "entities" - DONE
 - in order to fix multi-instantiation in e.g:
  stackObj := AType();  ## shall not allocates twice & copy

Implement "development mode" in compiler, if disabled then:
 - bc file generated by default - DONE
 - no jit by default - DONE
 - no compiler assertions - DONE
 - no trace logging invocations - DONE

Review conversion node handling - DONE
 - should be allocated in node constructors (not decl/resolve passes)

Overhaul concrete fields checking - DONE
 - distinguish between parameters that are ref-constrained and that aren't
 - handle lexically nested generic and non-generic types appropriately

Proper mutability handling: - DONE
 - in compound expressions, e.g. mut.immut.mut.immut ...
 - mutating and non-mutating methods

Array literals - DONE

Make VALUE type parameters proper instance fields - DONE
 - implement correct Array type handling

Implement proper modifiability determination across expression chains - DONE

Be able to specialize an immutable version of mutable generic types, so that they can accept immutable type bindings - DONE
 - review inheritance and mutability (including interface adapters)

Generate statically constant operations for statically constant value expressions - DONE
 - should also enable arbitrary declaration order of global constants

Support augmenting built-in types' definitions in tuplex code - DONE

Bounds checking on array element access (add implicit AST for this in TxElemDerefNode) - DONE

Bounds checking on array element assignment - DONE

Sequence interfaces first version - DONE

Range type - DONE

Advanced for-loops - DONE

String datatype - DONE

Panic statement - DONE

Foreign function interface - DONE

Syntactic sugar for ref and array types in type arguments (possibly chained), e.g. Subtype<&Int> instead of Subtype<Ref<Int>> - DONE

Make VALUE type parameter specializations share a general (but non-generic) supertype - DONE

Basic type reflection ( _typeid(), isa() ) - DONE

Conditional reference type casting: - DONE
    if other is oa : &Array { ... }

Array object assignment, review and test semantics - DONE

Dynamic-length arrays tests - bounds checking, copying, etc - DONE

Support main( args ) program arguments - DONE

Implement basic debugging info - DONE


Secure Initialization
---------------------
Ensure fields are always initialized - DONE

Implement advanced constructor initialization concept - DONE
 - 'self' as pseuodo-return value, so user constructors can operate object only after it is properly initialized
 - Allow instance members' inlined initializers

Constructor initialization validation check: That each constructor properly initializes all members (without inlined initializers) - DONE

Support named member initialization, preventing excessive copying-by-value for large members - DONE


Structure Syntax - Significant Whitespace
-----------------------------------------
Replace Flex with custom parser - DONE

Support indent / dedent without braces - DONE

Support statement termination with newline instead of semicolon - DONE

Clean up tests and tx code with new structure syntax - DONE
  -  For now, braces as statement and scope grouping is allowed, it is needed to support single-line statement lists.
  -  Brace-enclosed scopes are stripped of significant whitespace by scanner (i.e. no INDENT/DEDENT/NEWLINE).
  -  Parens, brackets, braces suppress NEWLINEs between them.
  -  A missing INDENT after COLON NEWLINE is an error.

Make blog post about new syntax - DONE


Remaining core array features:
------------------------------
Review array mutability vs element mutability handling - DONE
 - avoid inconsistency between them such as: ~Array<UByte>

Let nested array assignment statements support implicit initialization of assignee's outer array elements - DONE
    aaa : ~[4][4][4]UByte;  aaa[0][0][0] = 17;

Document array behavior, rules, and syntax
 - document nested arrays behavior

Array 'fill' constructor

Basic working Matrix type


Releasing Resources
-------------------
Freeing memory (delete statement) - DONE

Destructors



Misc
----
LLVM 11 update - DONE

Improve debugging info so that tuples' members can be inspected - DONE

Inclusive ranges syntax, e.g. 1..=10 for [1,10] inclusive - DONE


!! NEXT:  Arrays and Ranges site pages

!! NEXT:  Make interface required keyword for interface definitions, and make them implicitly mutable

!! NEXT:  Change keyword from 'virtual' to 'static'

!! NEXT:  Colon after sub-module header

Improved FFI support
 - opaque 64b pointer type
 - structs <-> Tuples

Number parsing functions atou() atoi() atof()


========= MILESTONE ==========



Dataspace support
 - overhaul syntax and grammar handling
 - full semantics and verification



REFACTORING
-----------
Make all AST nodes' state unambiguous - avoid the tree having mix of "originally created nodes" with
inserted wrapper nodes, transformed constructor calls, argument vectors etc - where the compiler pass state
becomes unclear.
 - Each compiler pass should execute exactly once on each node.
 - It should be perfectly clear which state the node is in.
 - Preferably, there shouldn't be an ocean of if statements to process on the nodes - and the passes should
   (typically) not need to run several times on the same subtree.
 -> perhaps pass PASS info with visitor?
 -> perhaps merge declaration pass with node construction?



Advanced array and range features
---------------------------------
Array remove/pop/reduce support (removing elements)

Array initialization from sequence; sequence expansion
 - requires custom modifiability handling
    arr := []Int( seq );  ## of type Sequencable<Int>
    arr := [ seq ... ];
    arr := [ 0..2 ... ];

Sub-range production:  arr[2..5] and sequencable[ 0..2..8 ]
 - syntactic sugar for Selection
   arr := c"0123456789"[ 0..2..10 ]  ## selects every second character

Support negative array indexing from array end

Support method overloading for closure-modifying (and not) methods
 - allow for loops to select sequencer()~ for mutable seq's

Auto-conversion of array initialization elements (literals; also from sequences?)

Virtual dereferencing of abstract references for array subscripting, implicitly creating a reference to the element?
    r : &Array;  s : &Array;
    r[0] == s[0]

For VALUEs below a threshold (e.g. <= 4), coge-gen individual specializations for efficiency



Advanced type handling
----------------------

casting from interface adapter to adaptee type - DONE

Support for non-primary-path polymorphism
 - casting to interface type that isn't primary-path-supertype

Support for entirely dynamic type casting from one interface (adapter) to another interface (adapter),
  via runtime type checking logic
  - may require interface-adapters built at runtime

cast / conditional type check of generic type parameters that aren't references

shall isa() checks return true even though mismatching mutability?

Support runtime is-a tests for interface adapters

Support boolean test expression for: Ref<P> is-a Ref<Q> if P is-a Q

Extend resolve_type()/define_type() to resolve_type_and_attributes()/define_type_and_attributes()
 - for bottom-up analysis of attributes:
   - generic-parameter-dependent (both TYPE and VALUE)
   - statically constant expressions
 - applies to RESOLUTION_PASS

Remove assumption that bound parameters are "concrete": Shall be ok to bind interfaces and abstract superclasses.
 - See elementary types that implement Enumerable<E>

Evaluate whether TYPE type parameter constraint types shall be resolved in each type specialization instead of in gen base type,
 in order to allow them to depend on the binding:
  - Would (probably) support more specific ERange specification:
    public type ERange< E derives Enumerable<E> > implements Range< E >
                                            ^^^


Arithmetic / logic features
-------------------
Make logical operators only execute the necessary terms, i.e. left-to-right and skip remaining when result is known

Separate bitwise and logical operators, so that bitwise can have higher priority than comparison operators:
  Bitwise: && || &| !
  Logical: & | != !

basic math intrinsics: max min abs sign mod rem

Basic Floatingpoint intrinsics:
 - floor & ceiling
 - fraction
 - sign
 - epsilon

Assignment-operators:
 - arithmetic ( += etc )
 - bitwise and logical



Improved overloading
--------------------
Support overloading of virtual methods

Overhaul function overloading (permitting "near-matches") together with implicit type conversion code



Implicit Tuples support
-----------------------
Tuple literals

Multi-valued function returns (i.e. return tuple)



Miscellaneous
-------------
Optimize codegen by not duplicating equivalent method specializations:
- Many methods can be shared across specializations - e.g. for mod and non-mod type bindings, and if the method
  is not directly dependent on the binding's type. Many ref-constrained type paramas will also allow for
  shared code generation.
- Possibly, skip methods not used. Note that if a method is used by any specialization, it must be included
  in vtable layout for all the specializations of that generic base type.

value equals in String

intrinsic Opt support, and perhaps null-safe dereferenceing (see Kotlin)

Improve inline lambda expression syntax, enable using newline/indent

Implement advanced debugging info
 - polymorphic methods (inheritance)
 - self, super fields in methods
 - non-local fields
 - expressions, rvalues, etc
 - generic type parameters?

break and continue out of nested loops

Make 'abstract' qualifier optional for members in Interface types?

Implement implicit static initializer function for types' static members and static code

Shared objects

Union typeclass

Enum typeclass

Switch-like statements

Support non-constant static initializers (i.e. executed before main())

Ideal concrete fields checking
 - ideally bottom-up: any construct that is dependent on generic parameter causes container to be dependent (and non-concrete)
 - methods may have function signature independent of generics, but contain code that is dependent on generic parameters

Auto-generate default (zero arguments) constructor if base type and all members without inlined initializers allow default construction?

A non-whitespace token after COLON means a single-line body terminated by NEWLINE.
    (Then brace-enclosed single-line scope, and double semicolon in some cases, may not be needed anymore.)

Array-of-structs and Struct-of-arrays via keywords?

Implement symbol visibility (private etc)?
