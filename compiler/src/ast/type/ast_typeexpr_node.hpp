#pragma once

#include "ast/ast_entitydefs.hpp"

/**
 * The context of this node refers to its outer scope. This node's entity, if any, refers to its inner scope.
 */
class TxTypeExpressionNode : public TxTypeResolvingNode {
    bool interfaceKW = false;
    bool mutableType = false;

protected:
    bool get_decl_interface_kw() const { return this->interfaceKW; }

    void declaration_pass() final {
        this->typeexpr_declaration_pass();
    }

    /** Performs declaration pass operations on this type expression node. To be overridden by subclasses as necessary. */
    virtual void typeexpr_declaration_pass() { }

public:
    explicit TxTypeExpressionNode( const TxLocation& ploc )
            : TxTypeResolvingNode( ploc ) {
    }

    virtual void set_interface( bool ifkw ) { this->interfaceKW = ifkw; this->mutableType |= ifkw; }

    virtual void set_requires_mutable( bool mut ) { this->mutableType = mut; }

    TxTypeExpressionNode* make_ast_copy() const override = 0;

    /** Returns true if this type expression requires the produced type to be mutable. Used by subclasses upon type creation. */
    bool requires_mutable_type() const { return this->mutableType; }

    /** Performs the code generation pass for this type expression and its sub-expressions.
     * This propagates code generation to type members.
     * Note that the LLVM types are generated by the TxActualType instances, not the AST.
     */
    virtual void code_gen_type( LlvmGenerationContext& context ) const = 0;
};


class TxQualType;
bool is_not_properly_concrete( const TxNode* node, TxQualType type );
